# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020-, The section authors, The jamovi Group, and Sebastian Jentschke (curating this documentation). This work is licensed under a Creative Commons Attribution-Non Commercial 4.0 International License.
# This file is distributed under the same license as the jamovi package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: jamovi\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-21 00:54+0200\n"
"PO-Revision-Date: 2020-07-20 23:23+0000\n"
"Language-Team: Danish (https://www.transifex.com/jamovi/teams/111618/da/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: da\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../development/tut_0203-state.rst:5
msgid "State"
msgstr ""

#: ../../development/tut_0203-state.rst:7
msgid ""
"The analyses demonstrated in the tutorial series so far, have been "
"completely *state*-less. This means that each time an analysis is run, (for "
"example, in response to a user checking a checkbox) it runs the analysis "
"from beginning to end. In many cases, this isn’t very efficient. A user may "
"run a t-test, and then select a checkbox requesting descriptives. Without "
"*state*, an analysis will recalculate the t-test results every time the "
"analysis is changed, even when the changed option has no impact on the "
"t-test results."
msgstr ""

#: ../../development/tut_0203-state.rst:16
msgid ""
"For many analyses, this isn’t a problem – indeed, a t-test runs very "
"quickly, so recalculating with every option change doesn’t really pose a "
"problem; the user still receives the results near instantaneously. However, "
"some analyses can take a considerable amount of time to run, and re-running "
"these in their entirety with every change leads to long delays and a poor "
"user experience. The solution to this problem is *state*."
msgstr ""

#: ../../development/tut_0203-state.rst:24
msgid ""
"In using state, an analysis retains information from when it was previously "
"run. If a user makes a change to an existing analysis, the analysis can make"
" use of the results that were calculated previously. Using the example of a "
"t-test, if the user checks a checkbox requesting an additional table of "
"descriptives, the analysis can re-use the t-test results from the last time "
"the analysis ran. However, if the user changes an option which affects the "
"t-test results – say, the type of t-test – then the analysis should not re-"
"use the earlier t-test results. Whether earlier results should be used or "
"not is determined by the ``clearWith`` property."
msgstr ""

#: ../../development/tut_0203-state.rst:36
msgid "``clearWith``"
msgstr ""

#: ../../development/tut_0203-state.rst:38
msgid ""
"Each results element in the .r.yaml file can have a ``clearWith`` property "
"specified. If no ``clearWith`` property is specified, then the default value"
" of ``*`` is used, which means the ``Table`` or ``Image`` will be cleared if"
" *any* option changes; *no* earlier results will ever be used. So far in "
"this tutorial series, all analyses have behaved in this way."
msgstr ""

#: ../../development/tut_0203-state.rst:45
msgid ""
"Specifying a ``clearWith`` property lets us specify the circumstances where "
"results should be re-used, and when not. For example, returning to our "
"*t-test*, our ``.a.yaml`` file might contain the following options:"
msgstr ""

#: ../../development/tut_0203-state.rst:79
msgid ""
"We could add the `clearWith` property to the t-test results table in the "
"``.r.yaml`` file as follows:"
msgstr ""

#: ../../development/tut_0203-state.rst:101
msgid ""
"This ``clearWith`` specifies that the table is to be cleared if any of the "
"options ``group``, ``alt`` or ``varEq`` change. Take note that we *haven’t* "
"added the ``deps`` option to this list. When the user adds additional "
"dependent variables, we don’t want it to clear the existing rows. You can "
"see what happens by running this example, and adding multiple dependent "
"variables one at a time."
msgstr ""

#: ../../development/tut_0203-state.rst:108
msgid ""
"Before we added this ``clearWith`` property, adding another dependent "
"variable caused the whole table to be cleared before being filled back in "
"again. Now with ``clearWith`` (without ``deps`` listed), adding an "
"additional dependent variable just adds another row, which is then filled "
"in. The old rows are not cleared. This new behaviour minimises the amount "
"the results flicker, and allows the user to see clearly what has changed in "
"the results in response to their actions."
msgstr ""

#: ../../development/tut_0203-state.rst:116
msgid ""
"However, it should be noted that we haven’t actually reduced the amount of "
"calculations being performed. Although the table is no longer cleared when "
"certain options are changed, our analysis implementation in the ``.b.R`` "
"file still loops over all the dependent variables and performs a t-test for "
"each. It then overrides the value already in the table with this newly "
"calculated value; the exact same value. This isn’t a problem, because the "
"t-test runs very quickly, but we can modify our ``.b.R`` file to not "
"calculate values which are already present in the table. We find out what "
"parts of the table are already filled in with the ``isFilled()`` method."
msgstr ""

#: ../../development/tut_0203-state.rst:128
msgid "``isFilled()``"
msgstr ""

#: ../../development/tut_0203-state.rst:130
msgid "The ``isFilled()`` method can be called with any of the following:"
msgstr ""

#: ../../development/tut_0203-state.rst:132
msgid "``table$isFilled()``"
msgstr ""

#: ../../development/tut_0203-state.rst:134
msgid "``table$isFilled(rowNo=i, col)``"
msgstr ""

#: ../../development/tut_0203-state.rst:136
msgid "``table$isFilled(rowKey=key, col)``"
msgstr ""

#: ../../development/tut_0203-state.rst:138
msgid ""
"By specifying or omitting different arguments, it is possible to query "
"whether the whole table is filled, whether a particular row or column is "
"filled, or whether a particular cell is filled. ``isFilled()`` returns "
"either ``TRUE`` or ``FALSE``."
msgstr ""

#: ../../development/tut_0203-state.rst:143
msgid ""
"Let’s return to our t-test example, to the ``.b.R`` file. We might modify "
"our ``.run()`` function as follows:"
msgstr ""

#: ../../development/tut_0203-state.rst:170
msgid ""
"We’ve added an if-statement which checks if the row is already filled. If it"
" is already filled in then it won’t call the ``t.test()`` function or spend "
"time populating the row. In this way we can skip calculations if the "
"appropriate results are already filled in."
msgstr ""

#: ../../development/tut_0203-state.rst:176
msgid "``setState()``"
msgstr ""

#: ../../development/tut_0203-state.rst:178
msgid ""
"However, sometimes we don’t want to just store the final results; sometimes "
"we want to store the intermediate objects as well. For example, we may want "
"to create a fit object, and then reuse this same fit object the next time "
"the analysis is run."
msgstr ""

#: ../../development/tut_0203-state.rst:183
msgid ""
"State can be saved and recovered from any results element, i.e. an ``Image``"
" or a ``Table``, using the ``setState()`` method and ``state`` property:"
msgstr ""

#: ../../development/tut_0203-state.rst:192
msgid "``$state`` will return ``NULL`` if no state has been set."
msgstr ""

#: ../../development/tut_0203-state.rst:194
msgid ""
"Note that the ``clearWith`` property also applies to the state attached to a"
" results element. The same mechanism can be used to selectively clear the "
"state or not, depending on what options have changed."
msgstr ""

#: ../../development/tut_0203-state.rst:198
msgid ""
"When using ``setState()`` and ``state``, an analysis will typically try and "
"retrieve the state as one of the first things it does. If the state doesn’t "
"exist (``state`` has a value of ``NULL``), then the analysis will perform "
"the calculations to create the object it requires and ``setState()`` that "
"object onto a results element. Following this, the analysis can populate the"
" tables and images from that object. Alternatively, if the state can be "
"retrieved, then the analysis can bypass the initial time-consuming "
"construction of the object, and just use the one from last time to populate "
"the tables and images."
msgstr ""

#: ../../development/tut_0203-state.rst:208
msgid ""
"**WARNING** some R objects, when serialised, take up a lot of space. If "
"these objects are large, then the save and restore process between analyses "
"will be very sluggish. As such, it’s worth investigating how large the "
"objects you want to store will be. The following will give you the "
"serialized size of an object in bytes:"
msgstr ""
